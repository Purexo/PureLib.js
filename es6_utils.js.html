<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: es6/utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: es6/utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {
  'use strict';
  /*
   * In this file you'll find some utils for ES6 compatible navigators
   */

  /**
   * asyncEach callback
   * @callback asyncEachCallback
   * @param {*} value - current value
   * @param {*} key - current key
   * @param {Array|Map|Set|string} iterable - iterable iterated
   */

  /**
   * make an async foreach for heavy iterable
   * 
   * @function asyncEach
   * @memberof pl
   * @static
   * @author Purexo &lt;contact@purexo.mom>
   * 
   * @param {Array|Map|Set|string} iterable - An iterable object
   * @param {asyncEachCallback} callback - cf Array.prototype.forEach signature
   * @param {any} [bind=iterable] - `this` context you want binding to callback
   * @returns {Promise} 
   */
  pl.asyncEach = function asyncEach(iterable, callback, bind) {
    return new Promise((resolve, reject) => {
      // check iterable
      if (typeof iterable[Symbol.iterator] !== 'function') {
        reject({ context: iterable, reason: 'not an iterable', done: false });
        return;
      }

      // check callback
      if (typeof callback !== 'function') {
        reject({ context: callback, reason: 'not a function', done: false });
        return;
      }

      // callback binding
      const binding = bind || iterable;
      callback = callback.bind(binding);

      // iterate over iterable
      for (let [key, value] of iterable) {
        callback(value, key, iterable);
      }

      // all right, process terminated, raise the result
      resolve(iterable);
    });
  }

  /**
   * @author Purexo &lt;contact@purexo.mom>
   * 
   * @class pl.Exception.NotIterableException
   * @memberof pl.Exception
   * @static
   * @augments pl.Exception
   * 
   * @param {string} message - message of Exception
   * @param {*} context - the incorrect object
   */
  pl.Exception.NotIterableException =
    function NotIterableException(message, context) {
      Exception.prototype.constructor.call(this, 'NotIterableException', message, context);
    }
  inherit(pl.Exception, pl.Exception.NotIterableException);

  /**
   * @typedef {Promise} Promise
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
   */

  /**
   * Work like Promise.all but without fail-fast behaviour and just accept an Array on Promise
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
   * 
   * @function PromiseWaitAll
   * @memberof pl
   * @static
   * @author Purexo &lt;contact@purexo.mom>
   * @author ZatsuneNoMoku https://github.com/ZatsuneNoMokou
   * 
   * @param {Object} promises - an Iterable of Promise you want wait resolve
   * @param {function} promises[Symbol.iterator]
   * @returns {Promise} .then of this Promise give a Map with each data given by each Promise of promises (same index)
   * @throws {pl.Exception.NotIterableException}
   */
  pl.PromiseWaitAll = function PromiseWaitAll(promises) {
    if (typeof promises[Symbol.iterator] !== 'function') {
      throw new pl.Exception.NotIterableException('promises should be an Iterable of Promise')
    }

    return new Promise(function (resolve, reject) {
      let count = typeof promises.size == 'function' ? promises.size() : promises.length;
      let results = new Map();

      // iterate over iterable
      // array not work with [index, value] array.entries() did
      var iterator = typeof promises.entries == 'function' ? promises.entries() : promises;
      for (let [index, promise] of iterator) {
        let handler = data => {
          results.set(index, data);
          if (--count == 0) {
            resolve(results);
          }
        }

        if (promise instanceof Promise) {
          promise.then(handler);
          promise.catch(handler);
        } else {
          handler(promise);
        }
      }
    });
  }

})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="pl.Collection.html">Collection</a></li><li><a href="pl.Exception.html">Exception</a></li><li><a href="pl.Exception.InvalidArgumentsException.html">InvalidArgumentsException</a></li><li><a href="pl.Exception.NotArrayException.html">NotArrayException</a></li><li><a href="pl.Exception.NotCollectionException.html">NotCollectionException</a></li><li><a href="pl.Exception.NotElementException.html">NotElementException</a></li><li><a href="pl.Exception.NotFunctionException.html">NotFunctionException</a></li><li><a href="pl.Exception.NotIterableException.html">NotIterableException</a></li><li><a href="pl.Exception.NotNullException.html">NotNullException</a></li><li><a href="pl.Exception.NotStringException.html">NotStringException</a></li></ul><h3>Namespaces</h3><ul><li><a href="pl.html">pl</a></li><li><a href="pl.fn.html">fn</a></li><li><a href="pl.LS.html">LS</a></li><li><a href="pl.SS.html">SS</a></li><li><a href="pl.xhr.html">xhr</a></li></ul><h3>Global</h3><ul><li><a href="global.html#plfunction">pl</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Aug 08 2016 20:37:06 GMT+0200 (DST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
